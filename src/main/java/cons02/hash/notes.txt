Что такое хеш-код?
● В Java это число типа int
● Хеш-код есть у каждого объекта
● Предназначение хеш-кода: повышение быстродействия при поиске,
добавлении и удалении элементов в коллекциях
● Желательно, чтобы хеш-код был уникальным для каждого конкретного
объекта, однако часто это не так
● В классе Object хеш-код это адрес объекта в памяти, поэтому каждый
объекта типа Object уникален
System.out.println(new Object().hashCode());


HashCode.
библиотека каталог
в хэш коды отсортированыдвоичный поиск


Согласованность equals и hashCode
Многие коллекции Java работают одновременно с equals и hashCode:
● Hashtable
● HashMap
● HashSet
● LinkedHashMap
● LinkedHashSet
Эти структуры данных используют для поиска и быстрого доступа к
объектам оба метода, так что необходима согласованность между
equals и hashCode.

Переопределение метода equals
● Рефлекcивность: a.equals(a) всегда true
● Симметричность: a.equals(b) ⇔ b.equals(a)
● Транзитивность: если a.equals(b) и b.equals(с),  то a.equals(с)
● Согласованность: многократный вызов a.equals(b) даёт всегда один и тот
же результат, при условии постоянства объектов a и b
● Сравнение с null: a.equals(null) всегда false
Примечание:
необходимо помнить, что требуется совместимость equals с hashCode()
a.equals(b) ⇒ хеш-коды a и b равны
public boolean equals(Object o)


Переопределение метода hashCode
● Согласованность: многократный вызов a.hashCode() даёт всегда один и
тот же результат, при условии постоянства свойств объекта a,
используемых в equals
● Совместимость с equals: a.equals(b) ⇒ hashCode(a) == hashCode(b)
● Повторяемость:  хеш-коды для неравных (по equals) объектов могут
совпадать
Примечание:
выдача различных результатов для неравных объектов
может повысить производительность хеш-таблиц.
public int hashCode()


Переопределение equals и hashCode
@Override
public boolean equals(Object o){
// код
}
@Override
public int hashCode(){
// код
}

!!!!!!!!!!!!сделать класс и перопределить

Правила переопределения equals
● Проверяем совпадение объектов (через совпадение ссылок)
● Проверяем параметр o на null
● Проверяем совпадение классов сравниваемых объектов
● Приводим obj к нужному классу
● Сравниваем ключевые свойства, то есть такие, которые
определяют равенство объектов
public boolean equals(Object o)


Правила переопределения hashCode
● Опираемся на те же свойства объекта, что и equals
● Исключаем или минимизируем коллизии. Для этого думаем как
обеспечить уникальность хеш-кодов для неравных объектов, либо как
сделать функцию хеш-кода равномерно распределённой
● Помним, что хеш-коды равных объектов должны совпадать
● Если свойства объекта представлены неточными типами float и double,
используем функции
○ Float.floatToIntBits()
○ Double.doubleToLongBits()
● Или, что проще всего и работает в большинстве случаев, используем
возможности среды для генерации hashCode()
public int hashCode()
