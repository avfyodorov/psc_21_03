Для чего нужно логирование
Давайте разберем реальные случаи, в которых логирование решало бы проблему.

Вот пример из моей работы. Есть точки приложений, которые интегрируются с другими сервисами.
Я использую логирование этих точек для “алиби”: если интеграция не сработает, будет легко разобраться,
с какой стороны возникла проблема.

Еще желательно логировать важную информацию, которая сохраняется в базу данных.
 Например создание пользователя администратора. Это как раз то, что хорошо бы логировать.

 Из известных решений по логированию в Java можно выделить:

     log4j
     JUL — java.util.logging
     JCL — jakarta commons logging
     Logback
     SLF4J — simple logging facade for java

 Обзорно рассмотрим каждое из них, а в практической части материала возьмем за основу связку Slf4j — log4j. Сейчас это может показаться странным, но не переживайте: к концу статьи все будет понятно.
 System.err.println
 Первоначально был, разумеется, System.err.println (вывод записи в консоль). Его и сейчас используют для быстрого получения лога при дебаге. Конечно, говорить о каких-то настройках здесь не приходится, поэтому просто запомним его и пойдем дальше.
 Log4j
 Это уже было полноценное решение, которое создавалось из потребностей разработчиков. Получился действительно интересный инструмент, который можно использовать.

 В силу разных обстоятельств это решение так и не попало в JDK, чем очень расстроило все комьюнити.

 В log4j были возможности по конфигурации таким образом, чтобы можно было включить логирование в пакете com.example.type и выключить его в подпакете com.example.type.generic. Это позволяло быстро отсечь то, что нужно логировать, от того, что не нужно.

 Здесь важно отметить, что есть две версии log4j: 1.2.х и 2.х.х, которые несовместимы друг с другом.

 log4j добавил такое понятие как appender, то есть инструмент, с помощью которого записываются логи и layout — форматирование логов. Это позволяет записывать только то, что нужно и как нужно. Больше о appender поговорим чуть позже.
 JUL — java.util.logging
 Одно из ключевых преимуществ это решения — JUL включен в JDK (Java development kit). К сожалению, при его разработке за основу взяли не популярный log4j, а решение от IBM, что и повлияло на его развитие. По факту на данный момент JUL есть, но им никто не пользуется.

 Из “такого себе”: в JUL уровни логирования отличаются от того, что есть в Logback, Log4j, Slf4j, и это ухудшает понимание между ними.

 Создание логгера более менее похожее. Для этого нужно сделать импорт:

 java.util.logging.Logger log = java.util.logging.Logger.getLogger(LoggingJul.class.getName());


 Имя класса специально передается для того, чтобы знать, откуда идет логирование.

 Начиная с Java 8, можно передавать Supplier<String>. Это помогает считать и создавать строку только в тот момент, когда это действительно нужно, а не каждый раз, как это было до этого.

 Только с выходом Java 8 разработчики решили важные проблемы, после чего JUL по-настоящему стало возможно в использовании. А именно, методы с аргументом Supplier<String> msgSupplier, как показано ниже:

 public void info(Supplier<String> msgSupplier) {
    log(Level.INFO, msgSupplier);
 }

 JCL — jakarta commons logging
 Из-за того, что долгое время не было промышленного стандарта в логировании и был период, когда многие создавали свой кастомный логгер, решили выпустить JCL — общую обертку, которая  использовалась бы над другими.

 Почему? Когда в проект добавлялись какие-то зависимости, они могли использовать логгер, отличный от логгера на проекте. Из-за этого они транзитивно добавлялись в проект, что создавало реальные проблемы при попытке все это собрать воедино.

 К сожалению, обертка была очень бедна на функциональность и никаких дополнений не вносила.

 Наверное, было бы удобно, если бы все использовали JCL для работы. Но на деле так не получалось, поэтому на данный момент применять JCL — не лучшая идея.
 Logback
 Как же тернист путь open-source… Logback написал тот же разработчик, что и log4j, чтобы создать ему преемника. В основе была та же идея, что и в log4j.

 Отличия были в том, что в logback:

     улучшена производительность;
     добавлена нативная поддержка slf4j;
     расширена опция фильтрации.

 Стандартно logback не требует каких-либо настроек и записывает все логи начиная от уровня DEBUG и выше. Если нужна настройка, ее можно выполнить через xml конфигурацию:

 <configuration>
     <appender name="FILE" class="ch.qos.logback.core.FileAppender">
         <file>app.log</file>
         <encoder>
             <pattern>%d{HH:mm:ss,SSS} %-5p [%c] - %m%n</pattern>
         </encoder>
     </appender>
     <logger name="org.hibernate.SQL" level="DEBUG" />
     <logger name="org.hibernate.type.descriptor.sql" level="TRACE" />
     <root level="info">
         <appender-ref ref="FILE" />
     </root>
 </configuration>

 SLF4J — simple logging facade for java
 Где-то в 2006 году один из отцов-основателей log4j вышел из проекта и создал slf4j — Simple Logging Facade for Java — обертку вокруг log4j, JUL, common-loggins и logback.

 Как видим, прогресс дошел до того, что создали обертку над оберткой…

 Причем она делится на две части: API, который используется в приложении и реализация, которая добавляется отдельными зависимостями для каждого вида логирования.

 Например, slf4j-log4j12.jar, slf4j-jdk14.jar. Достаточно подключить правильную реализацию и все: весь проект будет работать с ней.

 Slf4j поддерживает все новые функции, такие как форматирование строк для логирования. До этого была такая проблема. Допустим, есть запись в лог:

 log.debug("User " + user + " connected from " + request.getRemoteAddr());


 В объекте user происходит неявное преобразование user.toString() из-за конкатенации строк, и это занимает время, которое тормозит систему.

 И все ок, если мы дебажим приложение. Проблемы начинаются, если для этого класса уровень логирования INFO и выше. То есть этот лог не должен быть записан, и конкатенация строк также не должна быть произведена.

 По идее это должна была решить сама библиотека логирования. Причем это и оказалось самой большой проблемой первой версии log4j. Решения нормального не завезли, а предложили делать вот так:

 if (log.isDebugEnabled()) {
     log.debug("User " + user + " connected from " + request.getRemoteAddr());
 }


 То есть вместо одной строки логирования предлагали писать 3(!). Логирование должно минимизировать изменения в коде, и три строки явно противоречили общему подходу.

 У slf4j не было проблем совместимости с JDK и API, поэтому сходу возникло красивое решение:

 log.debug("User {} connected from {}", user, request.getRemoteAddr());


 где {} обозначают вставки аргументов, которые передаются в методе. То есть первая {} соответствует user, вторая {} — request.getRemoteAddr(). Благодаря чему, только в случае, если уровень логирования позволяет записывать в лог, это сообщение конкатенировать в единое.

 После этого SJF4J стал быстро расти в популярности, и на данный момент это лучшее решение.

 Поэтому будем рассматривать логирование на примере связки slf4j-log4j12.
 Что нужно логировать
 Разумеется, логировать все подряд не стоит. Иногда это и не нужно, и даже опасно. Например, если залогировать чьи-то личные данные и это каким-то образом всплывет на поверхность, будут реальные проблемы, особенно на проектах, ориентированных на Запад.

 Но есть и то, что логировать обязательно:

     Начало/конец работы приложения. Нужно знать, что приложение действительно запустилось, как мы и ожидали, и завершилось так же ожидаемо.
     Вопросы безопасности. Здесь хорошо бы логировать попытки подбора пароля, логирование входа важных юзеров и т.д.
     Некоторые состояния приложения. Например, переход из одного состояния в другое в бизнес процессе.
     Некоторая информация для дебага, с соответственным уровнем логирования.
     Некоторые SQL скрипты. Есть реальные случаи, когда это нужно. Опять-таки, умелым образом регулируя уровни, можно добиться отличных результатов.
     Выполняемые нити(Thread) могут быть логированы в случаях с проверкой корректной работы.

 Популярные ошибки в логировании
 Нюансов много, но можно выделить несколько частых ошибок:

     Избыток логирования. Не стоит логировать каждый шаг, который чисто теоретически может быть важным. Есть правило: логи могут нагружать работоспособность не более, чем на 10%. Иначе будут проблемы с производительностью.
     Логирование всех данных в один файл. Это приведет к тому, что в определенный момент чтение/запись в него будет очень сложной, не говоря о том, что есть ограничения по размеру файлов в определенных системах.
     Использование неверных уровней логирования. У каждого уровня логирования есть четкие границы, и их стоит соблюдать. Если граница расплывчатая, можно договориться какой из уровней использовать.

 Запись и отправка логов: Appender
 Этот процесс будем рассматривать на примере log4j: он предоставляет широкие возможности для записи/отправки логов:

     для записи в файл — решение DailyRollingFileAppender;
     для получения данных в консоль приложения — ConsoleAppender;
     для записи логов в базу данных — JDBCAppender;
     для контроля передачи через TCP/IP — TelnetAppender;
     для того, чтобы запись логов не била по быстродействию — AsyncAppender.

 Есть еще несколько реализаций: полный список можно получить здесь.

 Кстати, если нужного аппендера не будет, это не проблема. Можно написать свой аппендер, имплементировав интерфейс Appender, который как раз принимает log4j.
